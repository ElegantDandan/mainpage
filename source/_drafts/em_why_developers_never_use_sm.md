title:  为什么开发者们从不使用状态机
description: 
date: 2016-10-10
layout: post
comments: ture
categories:
- 嵌入式软件
---

原文: http://www.skorks.com/2011/09/why-developers-never-use-state-machines/

英文水平欠佳，中文也让人捉急，脑补较多请见谅。

---


Why Developers Never Use State Machines
-----------------------------------------
几个月前，我在Shopify博客上看到了一篇很棒的关于状态机的小博文。博文想表达的是，状态机很棒，开发人员应该更多地使用他们—— 根据我最近在CrowdHired中使用状态机的经历，我很赞同他的观点。但这篇博文让我思考，在我的开发者职业生涯中，有多少次真正用到了状态机（包括使用库或是自己做的抽象）？答案是0次，这让我非常震惊，比当我知道状态机非常有用时更加的震惊。所以我决定反省一下，找出原因——为什么我们更倾向于以一种特定的方式是管理我们的"state" "stauts", 却不去使用我们都呼吁的方式.（原文：we tend to manage our "state" and "status" fields in an ad-hoc fashion rather than doing what is clearly called for.）

We Don't Need One Until We Do
-------------------------------
问题是，**你几乎永远不可能构建一个满足所有需求的对象**，而是渐进的开发。（todo）

所以你不会早早地就觉得，你的对象有很复杂的状态机行为，复杂到需要一个“完整的”状态机（类似YAGNI原则），然后有一天你发现它已经变得很复杂——让感到你要投入的时间都已经能把它从头到尾重写一个了。这还是挺让人进退两难的。**这种问题的杀伤力很高，但在变成这种状态之前并没影响，而意识到的时候已经太晚了。**


状态机是一只蓬松的兔子(没有特别的危险性)
--------------------------------------------------------------------

A State Machine Is A Fluffy Bunny (Not Particularly Threatening)

对于我们这些拿到计算机科学学位的人,谈起计算理论课里关于状态机的知识,记忆里总是没好感的: 复杂的图表和符号，确定性状态机或是非确定性状态机，Moore和Mealy状态机,还有那些缩写（DFA，NFA，GNFA等）。这使我们高估了状态机的复杂性, 实用主义让我们觉得"完备的"状态机实在是大材小用了.

但是**在你的日常开发中, 要用到的状态机和这些计算机理论里描述的通常毫不相干**(除了..纯理论的东西). 你的用字符串表示一些状态(states), 用方法(method)表示那些引发状态转换的事件(event)——几乎都是这样(至少Ruby里的*state_machine*开发包中是这样). 重点是, 即使你只有两个状态, 使用状态机也并不是大材小用, 这样做更容易使一个临时的方案不断迭代下去, 前提是你有好用的现成的库.

Even A Good Tool Is Not A Good Tool
--------------------------------------------------------------------

我敢打赌你能用到的大多数语言中, 都有好用的状态机库(上述Ruby中的state_machine只是个例子). 但即使是一只蓬松的兔子, 也有一定的学习曲线(I am stretching the metaphor well past breaking point here). 在解决问题的过程中, 这大概不会成为一个会提出来的问题, 但是你能做的是把当前的解决方案替换掉, 因为我们往往在事后倾向于使用状态机库(我们的临时解决方案现在仍可用). 就像拥有“潜在的未来收益”的所有东西一样，它的直接价值是很难被证明的, 即使只是要说服自己（除非你以前有经验）. 平滑的学习曲线也只能让"我们可以在没有它的条件下活下来"这种想法进一步地扩大。一个工具, 如果不去使用它, 不管它有多好都毫无意义.

todo: 翻到这
 
这实在是难以体会（直到你已经穿过了这） - 更好的生活可以是多少，如果你给出一个很好的状态机库的机会。当我们终于在CrowdHired“忍辱负重”，并rejigged我们的一些核心对象的使用state_machine宝石，差异显而易见。

首先学习曲线是次要的，我确实花了通过源代码和文档去了几个小时，但之后，我有一个很好的想法可能并不能做到（我可能会做一个深入了解的state_machine宝石在某一点）。
整合本身几乎无痛，但走动所有的代码是内嵌在新的国家机器是一个很大的痛苦。事后看来，我们已经做到了这一点，当我们的对象只有一对夫妇州这本来是一件轻而易举的。
我们现在能够很容易地引入更多的国家给我们的用户额外的信息，以及允许我们跟踪的东西更细的晶粒。之前，它是YAGNI因为它是一个痛苦，现在我们发现，我们“艾会需要”毕竟，因为它是那么容易。
我们从状态转移的返回值现在是100％一致（真/假）。之前，我们正在返回的对象，对象，零，数组真/假取决于谁在写它时。
我们现在可以简单地通过state_machine-AUDIT_TRAIL下降，以保持我们的状态转换的审计线索（请参阅Shopify后），这是太辛苦把它挂在任何地方，所以我们什么都没有了。
我们删除了一堆代码，并改善了我们的代码库 - 就我而言总是值得追求的目标。
我的直觉感是谁读了Shopify后大多数人用它在精神上同意了，但并没有关于它（这是有点儿它是如何与我）。我们似乎回避状态机离开，由于其复杂性和/或无法量化的好处的误解。但是，有少于你想象的复杂性和更多的好处会比你只要你不尝试事后加装一个状态机的期望。所以，下一次你有一个甚至暗示有一个“状态”栏中的对象，只是夹头状态机在那里，你会很高兴你没有。我保证或你的钱回来:)。


真的很难欣赏（直到你经历了） - 如果你给一个好的状态机器库一个机会，可以有多好的生活。当我们终于在CrowdHired的“子弹”中重新启动了一些我们的核心对象来使用state_machine宝石时，这个区别立刻就明显了。

首先，学习曲线很小，我花了几个小时的时间来完成源码和文档，但之后，我有一个很好的想法，可以做甚么都不能做（我可以深入了解state_machine宝石在某一点）。
整合本身几乎是无痛的，但是将所有代码移动到与新的状态机一致的地方是一个很大的痛苦。事后看来，如果我们的对象只有几个州，那么这将是一个轻而易举的事情。
我们现在可以轻松地介绍更多的州，为我们的用户提供额外的信息，并让我们跟踪更细的谷物。在这是YAGNI之前，这是一个痛苦，现在我们发现我们“ai gonna需要”毕竟，因为它是那么容易。
我们从状态转换的返回值现在是100％一致（真/假）。在我们返回对象，数组的对象之前，nil，true / false取决于谁在写它和何时。
我们现在可以通过在state_machine-audit_trail（参见Shopify帖子）中放置状态转换的审计跟踪，之前太难以将其挂在任何地方，所以我们什么也没有。
我们删除了一堆代码，改进了我们的代码库 - 总是值得关注的目标。

我的内心感觉是，大部分阅读Shopify文章的人都精神上同意了这一点，但没有做任何事情（这和我一样）。 由于误解了它们的复杂性和/或无法量化效益，我们似乎已经舍弃了国家机器。 但是，比你想象的更复杂，比你预期的更多的好处，只要你不要在事实之后改装状态机。 所以下一次你有一个对象，甚至暗示有一个“状态”字段，只是在那里抓住状态机，你会很高兴你做的。 我保证或你的钱回:)


---
我想，大部分读过那篇[Shopify文章](https://engineering.shopify.com/17488160-why-developers-should-be-force-fed-state-machines)的人都精神上同意了这一点，但不会因此做任何事（这和我一样）. **我们似乎是有意回避着状态机, 因为他的复杂性, 以及无法量化的好处.** 但是, 实际上它并没有你想象的那么复杂, 以及能带来比你预期的更多的好处, 只要你不要在之前提到的糟糕情况发生之后才开始改用状态机. 所以, 当下次你需要构建一个对象有着一丝"状态"方面的线索, 只需丢一个状态机在那里就好, 之后你会为之高兴的. 我保证你的钱会回来 :)